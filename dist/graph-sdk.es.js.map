{"version":3,"file":"graph-sdk.es.js","sources":["../node_modules/svelte/src/constants.js","../node_modules/svelte/src/internal/client/utils.js","../node_modules/svelte/src/internal/client/constants.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/internal/client/errors.js","../node_modules/svelte/src/internal/client/reactivity/sources.js","../node_modules/svelte/src/internal/client/reactivity/effects.js","../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../node_modules/svelte/src/internal/client/runtime.js","../node_modules/svelte/src/internal/client/proxy.js","../src/indexeddb_wrapper.ts","../src/create_state.svelte.ts","../node_modules/tslib/tslib.es6.mjs","../node_modules/lodash.startswith/index.js","../node_modules/@gqlts/runtime/esm/client/getFieldFromPath.js","../node_modules/@gqlts/runtime/esm/client/generateGraphqlOperation.js","../node_modules/zen-observable-ts/module.js","../node_modules/@gqlts/runtime/esm/index.js","generated/index.js","../src/graph_utils.ts","../src/auth_sdk.ts","../src/graphql_call.ts","../src/batching.ts","../src/generated/index.js","../src/build_query.ts","../src/graphdb_handlers.ts","../src/create_db_states.ts","../src/index.ts"],"sourcesContent":["export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ANCHOR = '';\nexport const HYDRATION_END_ELSE = `${HYDRATION_END}!`; // used to indicate that an `{:else}...` block was rendered\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nexport const RawTextElements = ['textarea', 'script', 'style', 'title'];\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\nexport const namespace_svg = 'http://www.w3.org/2000/svg';\nexport const namespace_mathml = 'http://www.w3.org/1998/Math/MathML';\n\n// while `input` is also an interactive element, it is never moved by the browser, so we don't need to check for it\nexport const interactive_elements = new Set([\n\t'a',\n\t'button',\n\t'iframe',\n\t'embed',\n\t'select',\n\t'textarea'\n]);\n\nexport const disallowed_paragraph_contents = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'div',\n\t'dl',\n\t'fieldset',\n\t'figcapture',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hr',\n\t'menu',\n\t'nav',\n\t'ol',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul',\n\t'p'\n];\n\n// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nconst implied_end_tags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n/**\n * @param {string} tag\n * @param {string} parent_tag\n * @returns {boolean}\n */\nexport function is_tag_valid_with_parent(tag, parent_tag) {\n\t// First, let's check if we're in an unusual parsing mode...\n\tswitch (parent_tag) {\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\t\tcase 'select':\n\t\t\treturn (\n\t\t\t\ttag === 'option' ||\n\t\t\t\ttag === 'optgroup' ||\n\t\t\t\ttag === '#text' ||\n\t\t\t\ttag === 'hr' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\tcase 'optgroup':\n\t\t\treturn tag === 'option' || tag === '#text';\n\t\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t\t// but\n\t\tcase 'option':\n\t\t\treturn tag === '#text';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t\t// No special behavior since these rules fall back to \"in body\" mode for\n\t\t// all except special table nodes which cause bad parsing behavior anyway.\n\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\t\tcase 'tr':\n\t\t\treturn (\n\t\t\t\ttag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\t\tcase 'tbody':\n\t\tcase 'thead':\n\t\tcase 'tfoot':\n\t\t\treturn tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\t\tcase 'colgroup':\n\t\t\treturn tag === 'col' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\t\tcase 'table':\n\t\t\treturn (\n\t\t\t\ttag === 'caption' ||\n\t\t\t\ttag === 'colgroup' ||\n\t\t\t\ttag === 'tbody' ||\n\t\t\t\ttag === 'tfoot' ||\n\t\t\t\ttag === 'thead' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\t\tcase 'head':\n\t\t\treturn (\n\t\t\t\ttag === 'base' ||\n\t\t\t\ttag === 'basefont' ||\n\t\t\t\ttag === 'bgsound' ||\n\t\t\t\ttag === 'link' ||\n\t\t\t\ttag === 'meta' ||\n\t\t\t\ttag === 'title' ||\n\t\t\t\ttag === 'noscript' ||\n\t\t\t\ttag === 'noframes' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\t\tcase 'html':\n\t\t\treturn tag === 'head' || tag === 'body' || tag === 'frameset';\n\t\tcase 'frameset':\n\t\t\treturn tag === 'frame';\n\t\tcase '#document':\n\t\t\treturn tag === 'html';\n\t}\n\n\t// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch (tag) {\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\treturn (\n\t\t\t\tparent_tag !== 'h1' &&\n\t\t\t\tparent_tag !== 'h2' &&\n\t\t\t\tparent_tag !== 'h3' &&\n\t\t\t\tparent_tag !== 'h4' &&\n\t\t\t\tparent_tag !== 'h5' &&\n\t\t\t\tparent_tag !== 'h6'\n\t\t\t);\n\n\t\tcase 'rp':\n\t\tcase 'rt':\n\t\t\treturn implied_end_tags.indexOf(parent_tag) === -1;\n\n\t\tcase 'body':\n\t\tcase 'caption':\n\t\tcase 'col':\n\t\tcase 'colgroup':\n\t\tcase 'frameset':\n\t\tcase 'frame':\n\t\tcase 'head':\n\t\tcase 'html':\n\t\tcase 'tbody':\n\t\tcase 'td':\n\t\tcase 'tfoot':\n\t\tcase 'th':\n\t\tcase 'thead':\n\t\tcase 'tr':\n\t\t\t// These tags are only valid with a few parents that have special child\n\t\t\t// parsing rules -- if we're down here, then none of those matched and\n\t\t\t// so we allow it only if we don't know what the parent is, as all other\n\t\t\t// cases are invalid.\n\t\t\treturn parent_tag == null;\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {string} name\n * @param {\"include-on\" | \"exclude-on\"} [mode] - wether if name starts with `on` or `on` is excluded at this point\n */\nexport function is_capture_event(name, mode = 'exclude-on') {\n\tif (!name.endsWith('capture')) {\n\t\treturn false;\n\t}\n\treturn mode == 'exclude-on'\n\t\t? name !== 'gotpointercapture' && name !== 'lostpointercapture'\n\t\t: name !== 'ongotpointercapture' && name !== 'onlostpointercapture';\n}\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\nexport const HEAD_EFFECT = 1 << 18;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_FROZEN_SYMBOL = Symbol('$state.frozen');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `legacy.componentApi` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`legacy.componentApi\\` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Updating state inside a derived is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}\n\n/**\n * The `this={...}` property of a `<svelte:component>` must be a Svelte component, if defined\n * @returns {never}\n */\nexport function svelte_component_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_component_invalid_this_value\\nThe \\`this={...}\\` property of a \\`<svelte:component>\\` must be a Svelte component, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_component_invalid_this_value\");\n\t}\n}","import { DEV } from 'esm-env';\nimport {\n\tcurrent_component_context,\n\tcurrent_reaction,\n\tcurrent_dependencies,\n\tcurrent_effect,\n\tcurrent_untracked_writes,\n\tget,\n\tis_runes,\n\tmark_reactions,\n\tschedule_effect,\n\tset_current_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_version,\n\texecute_effect,\n\tinspect_effects\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport { CLEAN, DERIVED, DIRTY, BRANCH_EFFECT } from '../constants.js';\nimport { UNINITIALIZED } from '../../../constants.js';\nimport * as e from '../errors.js';\n\n/**\n * @template V\n * @param {V} v\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(v) {\n\treturn {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\tversion: 0\n\t};\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.equals = safe_equals;\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (current_component_context !== null && current_component_context.l !== null) {\n\t\t(current_component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('#client').Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tvar initialized = source.v !== UNINITIALIZED;\n\n\tif (\n\t\tinitialized &&\n\t\tcurrent_reaction !== null &&\n\t\tis_runes() &&\n\t\t(current_reaction.f & DERIVED) !== 0\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\tif (!source.equals(value)) {\n\t\tsource.v = value;\n\t\tsource.version = increment_version();\n\n\t\tmark_reactions(source, DIRTY, true);\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\t// We additionally want to skip this logic when initialising store sources\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tinitialized &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(source)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tset_current_untracked_writes([source]);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tfor (const effect of inspect_effects) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n","import {\n\tcheck_dirtiness,\n\tcurrent_component_context,\n\tcurrent_effect,\n\tcurrent_reaction,\n\tdestroy_effect_children,\n\tdev_current_component_function,\n\texecute_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_current_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../utils.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (current_effect === null && current_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (current_reaction !== null && (current_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").Reaction} parent_effect\n */\nexport function push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {import('#client').Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\n\t/** @type {import('#client').Effect} */\n\tvar effect = {\n\t\tctx: current_component_context,\n\t\tdeps: null,\n\t\tnodes: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : current_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\texecute_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes === null &&\n\t\teffect.teardown === null;\n\n\tif (!inert && !is_root && push) {\n\t\tif (current_effect !== null) {\n\t\t\tpush_effect(effect, current_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\t\tpush_effect(effect, current_reaction);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (current_reaction === null) {\n\t\treturn false;\n\t}\n\n\treturn (current_reaction.f & UNOWNED) === 0;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tcurrent_effect !== null &&\n\t\t(current_effect.f & RENDER_EFFECT) !== 0 &&\n\t\t// TODO do we actually need this? removing them changes nothing\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t(context.e ??= []).push(fn);\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\t/** @type {{ effect: null | import('#client').Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail-out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = current_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_current_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_current_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes !== null) {\n\t\t/** @type {import('#client').TemplateNode | null} */\n\t\tvar node = effect.nodes.start;\n\t\tvar end = effect.nodes.end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {import('#client').TemplateNode | null} */\n\t\t\tvar next =\n\t\t\t\tnode === end ? null : /** @type {import('#client').TemplateNode} */ (node.nextSibling);\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tif (effect.transitions) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && (effect.f & BRANCH_EFFECT) !== 0 && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\teffect.nodes =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {import('#client').Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {import('#client').Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {import('#client').TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {import('#client').TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {import('#client').TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {import('#client').Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\texecute_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { CLEAN, DERIVED, DESTROYED, DIRTY, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tcurrent_reaction,\n\tcurrent_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tmark_reactions,\n\tcurrent_skip_reaction,\n\texecute_reaction_fn,\n\tdestroy_effect_children,\n\tincrement_version\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\n\nexport let updating_derived = false;\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tlet flags = DERIVED | DIRTY;\n\tif (current_effect === null) flags |= UNOWNED;\n\n\t/** @type {import('#client').Derived<V>} */\n\tconst signal = {\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0\n\t};\n\n\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\tvar current_derived = /** @type {import('#client').Derived<V>} */ (current_reaction);\n\t\tif (current_derived.deriveds === null) {\n\t\t\tcurrent_derived.deriveds = [signal];\n\t\t} else {\n\t\t\tcurrent_derived.deriveds.push(signal);\n\t\t}\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nfunction destroy_derived_children(signal) {\n\tdestroy_effect_children(signal);\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tdestroy_derived_children(derived);\n\tvar value = execute_reaction_fn(derived);\n\tupdating_derived = previous_updating_derived;\n\n\tvar status =\n\t\t(current_skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null\n\t\t\t? MAYBE_DIRTY\n\t\t\t: CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t\tmark_reactions(derived, DIRTY, false);\n\t}\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\n\tsignal.first =\n\t\tsignal.last =\n\t\tsignal.deps =\n\t\tsignal.reactions =\n\t\t// @ts-expect-error `signal.fn` cannot be `null` while the signal is alive\n\t\tsignal.fn =\n\t\t\tnull;\n}\n","import { DEV } from 'esm-env';\nimport {\n\tdefine_property,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_frozen,\n\tobject_freeze\n} from './utils.js';\nimport { snapshot } from './proxy.js';\nimport {\n\tdestroy_effect,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED,\n\tSTATE_FROZEN_SYMBOL,\n\tINSPECT_EFFECT\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\nexport let inspect_effects = new Set();\n\n// Handle effect queues\n\n/** @type {import('#client').Effect[]} */\nlet current_queued_root_effects = [];\n\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | import('#client').Reaction} */\nexport let current_reaction = null;\n\n/** @param {null | import('#client').Reaction} reaction */\nexport function set_current_reaction(reaction) {\n\tcurrent_reaction = reaction;\n}\n\n/** @type {null | import('#client').Effect} */\nexport let current_effect = null;\n\n/** @param {null | import('#client').Effect} effect */\nexport function set_current_effect(effect) {\n\tcurrent_effect = effect;\n}\n\n/** @type {null | import('#client').Value[]} */\nexport let current_dependencies = null;\nlet current_dependencies_index = 0;\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | import('#client').Source[]}\n */\nexport let current_untracked_writes = null;\n\n/** @param {null | import('#client').Source[]} value */\nexport function set_current_untracked_writes(value) {\n\tcurrent_untracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let current_skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n// Handling runtime component context\n/** @type {import('#client').ComponentContext | null} */\nexport let current_component_context = null;\n\n/** @param {import('#client').ComponentContext | null} context */\nexport function set_current_component_context(context) {\n\tcurrent_component_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {import('#client').ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {import('#client').ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn current_version++;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn current_component_context !== null && current_component_context.l === null;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {import('#client').Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\tvar is_dirty = (flags & DIRTY) !== 0;\n\n\tif (is_dirty) {\n\t\treturn true;\n\t}\n\n\tvar is_unowned = (flags & UNOWNED) !== 0;\n\tvar is_disconnected = (flags & DISCONNECTED) !== 0;\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar length = dependencies.length;\n\t\t\tvar reactions;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (!is_dirty && check_dirtiness(/** @type {import('#client').Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {import('#client').Derived} **/ (dependency));\n\t\t\t\t}\n\n\t\t\t\tvar version = dependency.version;\n\n\t\t\t\tif (is_unowned) {\n\t\t\t\t\t// If we're working with an unowned derived signal, then we need to check\n\t\t\t\t\t// if our dependency write version is higher. If it is then we can assume\n\t\t\t\t\t// that state has changed to a newer version and thus this unowned signal\n\t\t\t\t\t// is also dirty.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!current_skip_reaction && !dependency?.reactions?.includes(reaction)) {\n\t\t\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !current_skip_reaction)\n\t\t\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t\t\t// if linked to the dependency source – otherwise future updates will not be caught.\n\t\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t\t}\n\t\t\t\t} else if ((reaction.f & DIRTY) !== 0) {\n\t\t\t\t\t// `signal` might now be dirty, as a result of calling `check_dirtiness` and/or `update_derived`\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (is_disconnected) {\n\t\t\t\t\t// It might be that the derived was was dereferenced from its dependencies but has now come alive again.\n\t\t\t\t\t// In thise case, we need to re-attach it to the graph and mark it dirty if any of its dependencies have\n\t\t\t\t\t// changed since.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\tis_dirty = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treactions = dependency.reactions;\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [reaction];\n\t\t\t\t\t} else if (!reactions.includes(reaction)) {\n\t\t\t\t\t\treactions.push(reaction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals are always maybe dirty, as we instead check their dependency versions.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t\tif (is_disconnected) {\n\t\t\treaction.f ^= DISCONNECTED;\n\t\t}\n\t}\n\n\treturn is_dirty;\n}\n\n/**\n * @param {Error} error\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {import(\"#client\").ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tvar filename = current_context.function?.filename;\n\n\t\tif (filename) {\n\t\t\tconst file = filename.split('/').at(-1);\n\t\t\tcomponent_stack.push(file);\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @returns {V}\n */\nexport function execute_reaction_fn(signal) {\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_reaction = current_reaction;\n\tconst previous_skip_reaction = current_skip_reaction;\n\n\tcurrent_dependencies = /** @type {null | import('#client').Value[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_reaction = (signal.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? signal : null;\n\tcurrent_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;\n\n\ttry {\n\t\tlet res = /** @type {Function} */ (0, signal.fn)();\n\t\tlet dependencies = /** @type {import('#client').Value<unknown>[]} **/ (signal.deps);\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\tconst deps_length = dependencies.length;\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_current_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? current_dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst current_dep_length = full_current_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst full_current_dependencies_set =\n\t\t\t\t\tcurrent_dep_length > 16 && deps_length - current_dependencies_index > 1\n\t\t\t\t\t\t? new Set(full_current_dependencies)\n\t\t\t\t\t\t: null;\n\t\t\t\tfor (i = current_dependencies_index; i < deps_length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tfull_current_dependencies_set !== null\n\t\t\t\t\t\t\t? !full_current_dependencies_set.has(dependency)\n\t\t\t\t\t\t\t: !full_current_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.deps = /** @type {import('#client').Value<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_reaction) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst reactions = dependency.reactions;\n\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [signal];\n\t\t\t\t\t} else if (reactions[reactions.length - 1] !== signal && !reactions.includes(signal)) {\n\t\t\t\t\t\treactions.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_reactions(signal, current_dependencies_index);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_reaction = previous_reaction;\n\t\tcurrent_skip_reaction = previous_skip_reaction;\n\t}\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @param {import('#client').Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tconst reactions = dependency.reactions;\n\tlet reactions_length = 0;\n\tif (reactions !== null) {\n\t\treactions_length = reactions.length - 1;\n\t\tconst index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (reactions_length === 0) {\n\t\t\t\tdependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[reactions_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (reactions_length === 0 && (dependency.f & DERIVED) !== 0) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {import('#client').Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tconst dependencies = signal.deps;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a reaction if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = true) {\n\tlet effect = signal.first;\n\tsignal.first = null;\n\tsignal.last = null;\n\tvar sibling;\n\twhile (effect !== null) {\n\t\tsibling = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = sibling;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @returns {void}\n */\nexport function execute_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar component_context = effect.ctx;\n\n\tvar previous_effect = current_effect;\n\tvar previous_component_context = current_component_context;\n\n\tcurrent_effect = effect;\n\tcurrent_component_context = component_context;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) === 0) {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = execute_reaction_fn(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, current_component_context);\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t\tcurrent_component_context = previous_component_context;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\te.effect_update_depth_exceeded();\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('#client').Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\t// When working with custom elements, the root effects might not have a root\n\t\t\tif (effect.first === null && (effect.f & BRANCH_EFFECT) === 0) {\n\t\t\t\tflush_queued_effects([effect]);\n\t\t\t} else {\n\t\t\t\t/** @type {import('#client').Effect[]} */\n\t\t\t\tvar collected_effects = [];\n\n\t\t\t\tprocess_effects(effect, collected_effects);\n\t\t\t\tflush_queued_effects(collected_effects);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<import('#client').Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\texecute_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `execute_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.nodes === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = current_queued_root_effects;\n\tcurrent_queued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & BRANCH_EFFECT) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t}\n\n\tcurrent_queued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {import('#client').Effect} effect\n * @param {import('#client').Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\t// TODO: we probably don't need to check for destroyed as it shouldn't be encountered?\n\t\tvar is_active = (flags & (DESTROYED | INERT)) === 0;\n\t\tvar is_branch = flags & BRANCH_EFFECT;\n\t\tvar is_clean = (flags & CLEAN) !== 0;\n\t\tvar child = current_effect.first;\n\n\t\t// Skip this branch if it's clean\n\t\tif (is_active && (!is_branch || !is_clean)) {\n\t\t\tif (is_branch) {\n\t\t\t\tset_signal_status(current_effect, CLEAN);\n\t\t\t}\n\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (!is_branch && check_dirtiness(current_effect)) {\n\t\t\t\t\texecute_effect(current_effect);\n\t\t\t\t\t// Child might have been mutated since running the effect\n\t\t\t\t\tchild = current_effect.first;\n\t\t\t\t}\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\tif (is_branch || is_clean) {\n\t\t\t\t\tif (child !== null) {\n\t\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(current_effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @param {boolean} [flush_previous]\n * @returns {any}\n */\nexport function flush_sync(fn, flush_previous = true) {\n\tvar previous_scheduler_mode = current_scheduler_mode;\n\tvar previous_queued_root_effects = current_queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {import('#client').Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tif (flush_previous) {\n\t\t\tflush_queued_root_effects(previous_queued_root_effects);\n\t\t}\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (current_queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\n\t\treturn result;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (current_reaction !== null) {\n\t\tconst unowned = (current_reaction.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_reaction.deps;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else if (\n\t\t\t\tcurrent_dependencies[current_dependencies.length - 1] !== signal &&\n\t\t\t\t!current_dependencies.includes(signal)\n\t\t\t) {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect);\n\t\t}\n\t}\n\n\tif (\n\t\t(flags & DERIVED) !== 0 &&\n\t\tcheck_dirtiness(/** @type {import('#client').Derived} */ (signal))\n\t) {\n\t\tupdate_derived(/** @type {import('#client').Derived} **/ (signal));\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {import('#client').Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Value} signal\n * @param {number} to_status should be DIRTY or MAYBE_DIRTY\n * @param {boolean} force_schedule\n * @returns {void}\n */\nexport function mark_reactions(signal, to_status, force_schedule) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// We skip any effects that are already dirty. Additionally, we also\n\t\t// skip if the reaction is the same as the current effect (except if we're not in runes or we\n\t\t// are in force schedule mode).\n\t\tif ((flags & DIRTY) !== 0 || ((!force_schedule || !runes) && reaction === current_effect)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, to_status);\n\n\t\t// If the signal is not clean, then skip over it – with the exception of unowned signals that\n\t\t// are already maybe dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t// effect.\n\t\tvar maybe_dirty = (flags & MAYBE_DIRTY) !== 0;\n\t\tvar unowned = (flags & UNOWNED) !== 0;\n\n\t\tif ((flags & CLEAN) !== 0 || (maybe_dirty && unowned)) {\n\t\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(\n\t\t\t\t\t/** @type {import('#client').Derived} */ (reaction),\n\t\t\t\t\tMAYBE_DIRTY,\n\t\t\t\t\tforce_schedule\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {import('#client').Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = current_reaction;\n\ttry {\n\t\tcurrent_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {import('#client').Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} val\n * @returns {val is import('#client').Value<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('#client').Value<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {import('#client').ComponentContext} */ (current_component_context)\n\t\t\t.function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (current_component_context.c ??= new Map(\n\t\tget_parent_context(current_component_context) || undefined\n\t));\n}\n\n/**\n * @param {import('#client').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => V} fallback lazy because could contain side effects\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => Promise<V>} fallback lazy because could contain side effects\n * @returns {Promise<V>}\n */\nexport async function value_or_fallback_async(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcurrent_component_context = {\n\t\tp: current_component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (!runes) {\n\t\tcurrent_component_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcurrent_component_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (var i = 0; i < effects.length; i++) {\n\t\t\t\teffect(effects[i]);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible ReactiveDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} value\n * @returns {V}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen in DEV.\n * @template T\n * @param {T} value\n * @returns {Readonly<T>}\n */\nexport function freeze(value) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If the object is already proxified, then snapshot the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tvalue = snapshot(value);\n\t\t}\n\t\tdefine_property(value, STATE_FROZEN_SYMBOL, {\n\t\t\tvalue: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false\n\t\t});\n\t\t// Freeze the object in DEV\n\t\tif (DEV) {\n\t\t\tobject_freeze(value);\n\t\t}\n\t}\n\treturn value;\n}\n","import { DEV } from 'esm-env';\nimport { get, current_component_context, untrack, current_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from './utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { mutable_source, source, set } from './reactivity/sources.js';\nimport { STATE_FROZEN_SYMBOL, STATE_SYMBOL } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [immutable]\n * @param {import('#client').ProxyMetadata | null} [parent]\n * @param {import('#client').Source<T>} [prev] dev mode only\n * @returns {import('#client').ProxyStateObject<T> | T}\n */\nexport function proxy(value, immutable = true, parent = null, prev) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {import('#client').ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// Since original parent relationship gets lost, we need to copy over ancestor owners\n\t\t\t\t\t// into current metadata. The object might still exist on both, so we need to widen it.\n\t\t\t\t\twiden_ownership(metadata, metadata);\n\t\t\t\t\tmetadata.parent = parent;\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {import('#client').ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\ti: immutable,\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].parent = parent;\n\n\t\t\t\tif (prev) {\n\t\t\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tconst prev_owners = prev?.v?.[STATE_SYMBOL]?.owners;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners =\n\t\t\t\t\t\tparent === null\n\t\t\t\t\t\t\t? current_component_context !== null\n\t\t\t\t\t\t\t\t? new Set([current_component_context.function])\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t: new Set();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {import('#client').ProxyStateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped) {\n\tif (typeof value === 'object' && value != null && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = Reflect.ownKeys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key === STATE_SYMBOL) continue;\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function snapshot(value) {\n\treturn /** @type {T} */ (\n\t\tunwrap(/** @type {import('#client').ProxyStateObject} */ (value), new Map())\n\t);\n}\n\n/**\n * @param {import('#client').Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/** @type {ProxyHandler<import('#client').ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i, metadata));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields – otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// create a source, but only if it's an own property and not a prototype property\n\t\tif (s === undefined && (!(prop in target) || get_descriptor(target, prop)?.writable)) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (\n\t\t\ts !== undefined ||\n\t\t\t(current_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i, metadata) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata.i, metadata));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t/** @type {import('#client').ProxyMetadata | undefined} */\n\t\t\tconst prop_metadata = value?.[STATE_SYMBOL];\n\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t}\n\t\t\tcheck_ownership(metadata);\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\te.state_prototype_fixed();\n\t};\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\tvar metadata = value[STATE_SYMBOL];\n\t\tif (metadata) {\n\t\t\treturn metadata.p;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n",null,null,"/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n","import startsWith from 'lodash.startswith';\nexport function getFieldFromPath(root, path) {\n    var current;\n    if (!root)\n        throw new Error('root type is not provided');\n    if (path.length === 0)\n        throw new Error(\"path is empty\");\n    path.forEach(function (f) {\n        var type = current ? current.type : root;\n        if (!type.fields)\n            throw new Error(\"type `\".concat(type.name, \"` does not have fields\"));\n        var possibleTypes = Object.keys(type.fields)\n            .filter(function (i) { return startsWith(i, 'on_'); })\n            .reduce(function (types, fieldName) {\n            var field = type.fields && type.fields[fieldName];\n            if (field)\n                types.push(field.type);\n            return types;\n        }, [type]);\n        var field = null;\n        possibleTypes.forEach(function (type) {\n            var found = type.fields && type.fields[f];\n            if (found)\n                field = found;\n        });\n        if (!field)\n            throw new Error(\"type `\".concat(type.name, \"` does not have a field `\").concat(f, \"`\"));\n        current = field;\n    });\n    return current;\n}\n//# sourceMappingURL=getFieldFromPath.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { getFieldFromPath } from './getFieldFromPath';\nfunction parseRequest(request, ctx, path) {\n    if (Array.isArray(request)) {\n        var _a = __read(request, 2), args_1 = _a[0], fields = _a[1];\n        var argNames = Object.keys(args_1);\n        if (argNames.length === 0) {\n            return parseRequest(fields, ctx, path);\n        }\n        var field_1 = getFieldFromPath(ctx.root, path);\n        return \"(\".concat(argNames.map(function (argName) {\n            ctx.varCounter++;\n            var varName = \"v\".concat(ctx.varCounter);\n            var typing = field_1.args && field_1.args[argName]; // typeMap used here, .args\n            if (!typing) {\n                throw new Error(\"no typing defined for argument `\".concat(argName, \"` in path `\").concat(path.join('.'), \"`\"));\n            }\n            ctx.variables[varName] = {\n                value: args_1[argName],\n                typing: typing,\n            };\n            return \"\".concat(argName, \":$\").concat(varName);\n        }), \")\").concat(parseRequest(fields, ctx, path));\n    }\n    else if (typeof request === 'object') {\n        var fields_1 = request;\n        var fieldNames = Object.keys(fields_1).filter(function (k) { return Boolean(fields_1[k]); });\n        if (fieldNames.length === 0) {\n            // TODO if fields are empty just return?\n            throw new Error('field selection should not be empty');\n        }\n        var type = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;\n        var scalarFields = type.scalar;\n        var scalarFieldsFragment = void 0;\n        if (fieldNames.includes('__scalar')) {\n            var falsyFieldNames_1 = new Set(Object.keys(fields_1).filter(function (k) { return !Boolean(fields_1[k]); }));\n            if (scalarFields === null || scalarFields === void 0 ? void 0 : scalarFields.length) {\n                ctx.fragmentCounter++;\n                scalarFieldsFragment = \"f\".concat(ctx.fragmentCounter);\n                ctx.fragments.push(\"fragment \".concat(scalarFieldsFragment, \" on \").concat(type.name, \"{\").concat(scalarFields\n                    .filter(function (f) { return !falsyFieldNames_1.has(f); })\n                    .join(','), \"}\"));\n            }\n        }\n        var fieldsSelection = fieldNames\n            .filter(function (f) { return !['__scalar', '__name'].includes(f); })\n            .map(function (f) {\n            var parsed = parseRequest(fields_1[f], ctx, __spreadArray(__spreadArray([], __read(path), false), [f], false));\n            if (f.startsWith('on_')) {\n                ctx.fragmentCounter++;\n                var implementationFragment = \"f\".concat(ctx.fragmentCounter);\n                var typeMatch = f.match(/^on_(.+)/);\n                if (!typeMatch || !typeMatch[1])\n                    throw new Error('match failed');\n                ctx.fragments.push(\"fragment \".concat(implementationFragment, \" on \").concat(typeMatch[1]).concat(parsed));\n                return \"...\".concat(implementationFragment);\n            }\n            else {\n                return \"\".concat(f).concat(parsed);\n            }\n        })\n            .concat(scalarFieldsFragment ? [\"...\".concat(scalarFieldsFragment)] : [])\n            .join(',');\n        return \"{\".concat(fieldsSelection, \"}\");\n    }\n    else {\n        return '';\n    }\n}\nexport function generateGraphqlOperation(operation, root, fields) {\n    var ctx = {\n        root: root,\n        varCounter: 0,\n        variables: {},\n        fragmentCounter: 0,\n        fragments: [],\n    };\n    var result = parseRequest(fields, ctx, []);\n    var varNames = Object.keys(ctx.variables);\n    var varsString = varNames.length > 0\n        ? \"(\".concat(varNames.map(function (v) {\n            var variableType = ctx.variables[v].typing[1];\n            //   console.log('variableType', variableType)\n            return \"$\".concat(v, \":\").concat(variableType);\n        }), \")\")\n        : '';\n    var operationName = (fields === null || fields === void 0 ? void 0 : fields.__name) || '';\n    return {\n        query: __spreadArray([\"\".concat(operation, \" \").concat(operationName).concat(varsString).concat(result)], __read(ctx.fragments), false).join(','),\n        variables: Object.keys(ctx.variables).reduce(function (r, v) {\n            r[v] = ctx.variables[v].value;\n            return r;\n        }, {}),\n    };\n}\n//# sourceMappingURL=generateGraphqlOperation.js.map","function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport { Observable };\n","export { createClient } from './client/createClient';\nexport { generateGraphqlOperation } from './client/generateGraphqlOperation';\nexport { linkTypeMap } from './client/linkTypeMap';\nexport { Observable } from 'zen-observable-ts';\nexport { createFetcher } from './fetcher';\nexport { ClientError } from './error';\nexport var everything = {\n    __scalar: true,\n};\nexport function assertSameVersion(generatedWithVersion) {\n    try {\n        if (typeof require === 'undefined') {\n            return;\n        }\n        var version = require('../package.json').version;\n        if (generatedWithVersion && generatedWithVersion.trim() != version.trim()) {\n            console.warn(\"[WARNING]: gqlts client library has been generated with a different version of '@gqlts/runtime', update both packages to have the same version - package.json: \".concat(version, \" - generated with: \").concat(generatedWithVersion));\n        }\n    }\n    catch (_a) { }\n}\n//\n//# sourceMappingURL=index.js.map","\nimport {\n  createClient as createClientOriginal,\n  assertSameVersion,\n  generateGraphqlOperation,\n} from '@gqlts/runtime'\nvar typeMap = linkTypeMap(types)\n// export * from './guards.esm'\n\nexport var version = \"3.2.20-beta.228\"\nassertSameVersion(version)\n\nexport var createClient =\n  function (options) {\n    options = options || {}\n    var optionsCopy = {\n      url: \"https://graphendpoint.test/v1/graphql\",\n      // queryRoot: typeMap.Query,\n      // mutationRoot: typeMap.Mutation,\n      // subscriptionRoot: typeMap.Subscription,\n    }\n    for (var name in options) {\n      optionsCopy[name] = options[name];\n    }\n    return createClientOriginal(optionsCopy)\n  }\n\n\nexport var generateQueryOp = function (fields) {\n  return generateGraphqlOperation('query', typeMap.Query, fields)\n}\nexport var generateMutationOp = function (fields) {\n  return generateGraphqlOperation('mutation', typeMap.Mutation, fields)\n}\nexport var generateSubscriptionOp = function (fields) {\n  return generateGraphqlOperation('subscription', typeMap.Subscription, fields)\n}\nexport var everything = {\n  __scalar: true\n}\n",null,null,null,null,"\nimport {\n  createClient as createClientOriginal,\n  assertSameVersion,\n  generateGraphqlOperation,\n} from '@gqlts/runtime'\nvar typeMap = linkTypeMap(types)\n// export * from './guards.esm'\n\nexport var version = \"3.2.20-beta.228\"\nassertSameVersion(version)\n\nexport var createClient =\n  function (options) {\n    options = options || {}\n    var optionsCopy = {\n      url: \"https://graphendpoint.test/v1/graphql\",\n      // queryRoot: typeMap.Query,\n      // mutationRoot: typeMap.Mutation,\n      // subscriptionRoot: typeMap.Subscription,\n    }\n    for (var name in options) {\n      optionsCopy[name] = options[name];\n    }\n    return createClientOriginal(optionsCopy)\n  }\n\n\nexport var generateQueryOp = function (fields) {\n  return generateGraphqlOperation('query', typeMap.Query, fields)\n}\nexport var generateMutationOp = function (fields) {\n  return generateGraphqlOperation('mutation', typeMap.Mutation, fields)\n}\nexport var generateSubscriptionOp = function (fields) {\n  return generateGraphqlOperation('subscription', typeMap.Subscription, fields)\n}\nexport var everything = {\n  __scalar: true\n}\n",null,null,null,null],"names":["UNINITIALIZED","is_array","is_frozen","define_property","get_descriptor","object_prototype","array_prototype","get_prototype_of","DERIVED","EFFECT","RENDER_EFFECT","BLOCK_EFFECT","BRANCH_EFFECT","ROOT_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","HEAD_EFFECT","STATE_SYMBOL","STATE_FROZEN_SYMBOL","equals","value","safe_not_equal","a","b","safe_equals","effect_update_depth_exceeded","state_unsafe_mutation","source","v","mutable_source","initial_value","_a","s","current_component_context","set","initialized","current_reaction","is_runes","e.state_unsafe_mutation","increment_version","mark_reactions","current_effect","current_dependencies","set_signal_status","schedule_effect","current_untracked_writes","set_current_untracked_writes","execute_effect_teardown","effect","teardown","previous_reaction","set_current_reaction","destroy_effect","remove_dom","removed","node","end","next","destroy_effect_children","remove_reactions","transition","parent","unlink_effect","prev","destroy_derived_children","signal","deriveds","i","destroy_derived","update_derived","derived","execute_reaction_fn","status","current_skip_reaction","is_micro_task_queued","is_flushing_effect","current_queued_root_effects","flush_count","reaction","current_dependencies_index","current_version","check_dirtiness","flags","is_dirty","is_unowned","is_disconnected","dependencies","length","reactions","dependency","version","handle_error","error","component_context","previous_dependencies","previous_dependencies_index","previous_untracked_writes","previous_skip_reaction","res","deps_length","full_current_dependencies","full_current_dependencies_set","remove_reaction","reactions_length","index","start_index","active_dependencies","sibling","execute_effect","previous_effect","previous_component_context","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","previously_flushing_effect","flush_queued_effects","collected_effects","process_effects","effects","process_deferred","previous_queued_root_effects","main_loop","is_active","is_branch","is_clean","child","parent_sibling","get","unowned","to_status","force_schedule","runes","maybe_dirty","untrack","fn","STATUS_MASK","proxy","immutable","metadata","prototype","state_proxy_handler","update_version","d","target","prop","descriptor","boolean","ls","receiver","has","not_has","IndexedDBWrapper","dbName","storeName","__publicField","resolve","reject","request","event","id","transaction","objectStore","document","indexedb_initialized","indexed_db_wrapper","browser","is_device_native","browser_storage","Preferences","args","init_states_storage","storage","Capacitor","PreferencesLib","create_state","state_name","persist","mutate_value_fn","populate_fn","populate_callback","on_change","current_state","get_stored_value","stored_value","get_capacitor_store","get_indexed_db_store","get_local_storage_store","populate_fn_handler","set_value","update_state","callback","updated_value","new_value","$.get","persistStore","_on_change","on_change_handler","create_on_change_handler","key","set_capacitor_store","setIndexedDBStore","setLocalStorageStore","insert_document","string_value","on_change_fns_map","call_back","destroy_delay","random_string","unsub","characters","result","charactersLength","__read","o","n","m","r","ar","e","__spreadArray","to","from","pack","l","INFINITY","MAX_INTEGER","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","freeGlobal","global","freeSelf","root","objectProto","objectToString","Symbol","symbolProto","symbolToString","baseClamp","number","lower","upper","baseToString","isSymbol","isObject","type","isObjectLike","toFinite","toNumber","sign","toInteger","remainder","other","isBinary","toString","startsWith","string","position","lodash_startswith","getFieldFromPath","path","current","f","possibleTypes","types","fieldName","field","found","parseRequest","ctx","args_1","fields","argNames","field_1","argName","varName","typing","fields_1","fieldNames","k","scalarFields","scalarFieldsFragment","falsyFieldNames_1","fieldsSelection","parsed","implementationFragment","typeMatch","generateGraphqlOperation","operation","varNames","varsString","variableType","operationName","hasSymbols","hasSymbol","name","assertSameVersion","generatedWithVersion","typeMap","generateQueryOp","generateMutationOp","is_array_valid","input","deep_merge","update_array_or_append_rune_using_id","rune","object","rune_length","clean_object","obj","cleaned_obj","graph_utils","on_authenticated_fns_set","on_change_fns_set","jwt_handlers","token","decoded_token","parsed_payload","auth_sdk_fn","token_refresh_timeout","post_sign_in_flow_fn","auth_state_value","app_auth_state_variable","AUTH_ENDPOINT","fetch_function","tokens_store","create_persistent_storage","create_refresh_timeout","tokens","access_token","refresh_token","now","token_expiry","perform_refresh_token","change_auth_state","handlers","options","username","password","url","fetch_data","data","success","current_token","no_tokens","initial_access_token","change_value","previous_state","on_authenticated_handler","state","store_name","storage_string","storage_value","auth_sdk","query_queue","mutation_queue","BATCH_INTERVAL_MS","query_timeout","mutation_timeout","GRAPH_ENDPOINT","active_fetch_function","init_graph_call","graph_endpoint","graphql_call_internal","query","variables","call_object","response","unauthorized_graphql_call","graphql_call","is_mutation","alias","queue","timeout_ref","combine_fn","combine_graphql_mutations","combine_graphql_queries","item","promise","innerResolve","innerReject","schedule_queue_processing","process_queue","items","query_objects","combined","final_results","return_result","queries","combinedQueryParts","combinedVariables","variableCounter","globalVariableTypes","currentVariables","currentQuery","variableTypeMatches","localVariableTypes","match","newVariableNames","newVarName","oldVarName","queryAlias","combinedVariablesKeys","variableDeclarations","mutations","mutation","mutationAlias","batch_queries","operations","final_op","results","results_tmp","acc","batch_mutations","mutate","collection","return_fields","delete_one","read_one","read_many","read","query_build","delete_id","graph_operations","create_db_object_state","many_q","single_q","create_q","update_q","delete_q","options_fn","auto_populate","new_return_fields","one","fn_arguments","read_options","many","update_one","_b","create_one","create_db_array_state","soft_delete_one","soft_delete_op","body","fetch_options","create_graphdb_client","auth_endpoint"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,12,13,14,15,16,17]}